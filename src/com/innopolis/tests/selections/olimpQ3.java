package com.innopolis.tests.selections;

/*
Скидки
При крупной покупке магазин даёт N карточек со скидкой.
У карточки две стороны:
front - число a, уменьшает текущую цену на a ( целое, 1 <= a <= 10000)
reverse - число b, уменьшает цену на b% == умножает цену на (1 - b/100) (целое, 1 <= b <= 99)
Они могут различаться на картой карточке.
Если цена становится < 0, то покупка отдаётся бесплатно.
Все действия со скидками производятся с float или double.

Петя собирается купить Феррари. Цена изначально X.
Нужно выяснить как оптимально использовать карточки, чтобы окончательная цена Феррари была как можно меньше.

Вывод:
N строк с карточками в порядке их необходимого использования.
Сначала номер карты, затем название стороны (front/reverse).
Конечная цена должна отличаться от оптимальной не более, чем на 0,000000001.

Пример:
Ввод:
3 1000      // N и X
10 1        // front и reverse первой карточки
20 1        // front и reverse второй карточки
10 2        // front и reverse третьей карточки

Вывод:
3 reverse   // третья карточка, обратная сторона
1 front     // первая карточка, фронтальная сторона
2 front     // вторая карточка, фронтальная сторона

Примечание: после применения 3ей карточки, он получает скидку 2% = 20, цена становится 980. Затем -10 и -20, цена = 950.
 */

import java.util.Scanner;

public class olimpQ3 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n, x;
        n = scanner.nextInt();  // 1 <= n <= 50
        x = scanner.nextInt();  // 1 <= x <= Math.pow(10, 9) (10 в степени 9)

        // заполняем массивы данных по карточкам с обеих сторон
        int[] front = new int[n];
        int[] reverse = new int[n];
        for (int i = 0; i < n; i++) {
            front[i] = scanner.nextInt();
            reverse[i] = scanner.nextInt();
        }

        for (int i = 0; i < n; i++) {

        }

        float newPrice;



    }
}
